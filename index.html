<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WhatsApp ZIP Viewer (fflate, single file)</title>
<style>
  :root {
    --bg: #0f141a;
    --panel: #121a22;
    --ink: #e6edf3;
    --muted: #9fb1c1;
    --accent: #3aa0ff;
    --bubble-left: #1f2a36;
    --bubble-right: #0b5fff1f;
    --warn: #ffb400;
    --radius: 14px;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; background: var(--bg); color: var(--ink); margin: 0; font: 15px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, Noto Sans, "Apple Color Emoji","Segoe UI Emoji"; }
  a { color: var(--accent); text-decoration: none; }
  a:hover { text-decoration: underline; }

  /* Control Panel */
  header {
    position: sticky; top: 0; z-index: 5;
    background: linear-gradient(180deg, rgba(0,0,0,0.45), rgba(0,0,0,0)) , var(--panel);
    border-bottom: 1px solid #1d2935;
    transition: all 0.3s ease;
  }
  
  .control-panel {
    padding: 16px 20px;
    transition: all 0.3s ease;
  }
  
  .control-panel.minimized {
    padding: 8px 20px;
  }
  
  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(45, 57, 72, 0.5);
  }
  
  .panel-header.minimized {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
  }
  
  .panel-title {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .title { 
    font-weight: 600; 
    font-size: 18px;
    opacity: 0.9; 
    margin: 0;
  }
  
  .minimize-btn {
    background: rgba(22, 32, 42, 0.8);
    border: 1px solid #2a3a4b;
    color: var(--ink);
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  
  .minimize-btn:hover {
    border-color: #3b5168;
    background: rgba(26, 37, 47, 0.9);
  }
  
  .panel-content {
    overflow: hidden;
    transition: all 0.3s ease;
  }
  
  .panel-content.minimized {
    max-height: 0;
    opacity: 0;
  }
  
  .section {
    margin-bottom: 20px;
  }
  
  .section:last-child {
    margin-bottom: 0;
  }
  
  .section-title {
    font-size: 13px;
    font-weight: 600;
    color: var(--muted);
    margin-bottom: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .bar { 
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 20px; 
    align-items: center; 
  }
  .file-btn {
    appearance: none; border: 1px solid #2a3a4b; background: #16202a; color: var(--ink);
    padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 600;
  }
  .file-btn:hover { border-color:#3b5168; }
  input[type="file"] { display:none; }
  .filename { color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 40vw; }
  .sp { flex: 1 1 auto; }
  .filter-grid {
    display: grid;
    grid-template-columns: 2fr 1fr 1fr;
    gap: 12px;
    align-items: stretch;
  }
  
  @media (max-width: 768px) {
    .filter-grid {
      grid-template-columns: 1fr;
    }
  }
  
  .filter-input, .type-filter, .ext-filter {
    padding: 12px 14px; 
    border-radius: 10px; 
    border: 1px solid #2a3a4b; 
    background: #0d141b; 
    color: var(--ink);
    font-size: 14px;
    transition: all 0.2s ease;
  }
  
  .filter-input:focus, .type-filter:focus, .ext-filter:focus {
    border-color: var(--primary);
    outline: none;
    background: #0f1621;
  }
  
  .file-section {
    display: grid;
    grid-template-columns: auto auto 1fr;
    gap: 16px;
    align-items: center;
  }
  
  .filename-display {
    font-size: 13px;
    color: var(--muted);
    opacity: 0.8;
  }
  
  .date-nav { 
    display: grid;
    grid-template-columns: auto auto 1fr auto auto;
    gap: 12px;
    align-items: center;
    padding: 16px 20px; 
    background: rgba(13, 20, 27, 0.6); 
    border: 1px solid #2a3a4b; 
    border-radius: 12px;
    backdrop-filter: blur(10px);
  }
  
  .date-nav-btn {
    appearance: none; 
    border: 1px solid #2a3a4b; 
    background: rgba(22, 32, 42, 0.8); 
    color: var(--ink);
    padding: 10px 14px; 
    border-radius: 8px; 
    cursor: pointer; 
    font-size: 14px; 
    font-weight: 600;
    min-width: 44px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .date-nav-btn:hover { 
    border-color: #3b5168; 
    background: rgba(26, 37, 47, 0.9); 
    transform: translateY(-1px);
  }
  
  .date-control { 
    position: relative; 
    justify-self: center;
    display: flex;
    align-items: center;
    min-width: 120px;
    justify-content: center;
  }
  
  .current-date-btn { 
    color: var(--ink); 
    font-size: 14px; 
    font-weight: 600; 
    cursor: pointer; 
    padding: 10px 16px; 
    border-radius: 8px;
    background: rgba(22, 32, 42, 0.8);
    border: 1px solid #2a3a4b;
    transition: all 0.2s ease;
    min-width: 140px;
    text-align: center;
    display: inline-block;
  }
  
  .current-date-btn:hover { 
    border-color: #3b5168; 
    background: rgba(26, 37, 47, 0.9); 
  }
  
  .date-input-panel {
    position: absolute; top: 100%; left: 50%; transform: translateX(-50%);
    background: #0d141b; border: 1px solid #3b5168; border-radius: 8px;
    padding: 8px; margin-top: 4px; min-width: 200px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 10;
  }
  
  .jump-date-input {
    width: 100%; margin-bottom: 6px;
    padding: 8px; border-radius: 4px; border: 1px solid #2a3a4b; 
    background:#16202a; color: var(--ink); font-size: 13px;
  }
  .jump-date-input:focus {
    border-color: #3b5168; outline: none; background: #1a252f;
  }
  
  .date-input-buttons { display: flex; gap: 4px; }
  .date-input-btn {
    flex: 1; padding: 4px 8px; border-radius: 4px; border: 1px solid #2a3a4b;
    background: #16202a; color: var(--ink); cursor: pointer; font-size: 12px; font-weight: 600;
  }
  .date-input-btn:hover { border-color: #3b5168; background: #1a252f; }
  .date-input-btn.cancel:hover { border-color: #ff6b6b; background: #2a1616; }

  .dropzone {
    margin-top: 8px;
    border: 1px dashed #2a3a4b; border-radius: 10px; padding: 10px;
    display:flex; gap:8px; align-items:center; color: var(--muted);
  }
  .dropzone.drag { border-color: var(--accent); color: var(--ink); background:#0b1220; }

  .stats {
    display:flex; gap:10px; flex-wrap:wrap; margin-top: 8px; color: var(--muted); font-size: 13px;
  }
  .stats b { color: var(--ink); }

  .progress { margin-top: 6px; color: var(--muted); font-size: 13px; min-height: 1.2em; }
  
  .progress-bar-container {
    width: 100%;
    height: 4px;
    background: var(--bg-secondary);
    border-radius: 2px;
    margin-top: 4px;
    overflow: hidden;
    display: none;
  }
  
  .progress-bar {
    height: 100%;
    background: var(--primary);
    width: 0%;
    transition: width 0.3s ease;
    border-radius: 2px;
  }
  
  .spinner {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 2px solid var(--muted);
    border-radius: 50%;
    border-top-color: var(--primary);
    animation: spin 1s ease-in-out infinite;
    margin-right: 6px;
    vertical-align: middle;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Main/chat area - ListView styles */
  main { 
    height: calc(100dvh - 200px); 
    overflow: auto; 
    padding: 0; 
    transition: all 0.3s ease;
  }
  
  main.panel-minimized {
    height: calc(100dvh - 80px);
  }
  
  @media (max-width: 768px) { 
    main { height: calc(100dvh - 240px); }
    main.panel-minimized { height: calc(100dvh - 80px); }
  }
  .chat {
    max-width: 900px; 
    margin: 0 auto; 
    height: 100%;
    position: relative;
    background: var(--bg);
  }

  /* WhatsApp-style ListView Items */
  .list-item {
    display: flex;
    flex-direction: column;
    padding: 8px 16px;
    background: transparent;
    min-height: auto;
    word-wrap: break-word; 
    overflow-wrap: anywhere;
    position: relative;
  }
  
  .list-item.highlighted {
    background: rgba(0,150,255,0.1);
    animation: highlight-fade 3s ease-out;
  }
  
  @keyframes highlight-fade {
    0% { background: rgba(0,150,255,0.2); }
    100% { background: transparent; }
  }

  /* Message Bubble Container */
  .message-bubble {
    display: flex;
    flex-direction: column;
    max-width: 75%;
    margin: 4px 0;
    padding: 8px 12px;
    border-radius: 12px;
    background: var(--bubble-left, #2d3748);
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    position: relative;
    word-wrap: break-word;
    overflow-wrap: anywhere;
  }
  
  /* Right-aligned messages (sent by main user) */
  .message-bubble.sent {
    align-self: flex-end;
    background: var(--bubble-right, #25d366);
    color: #fff;
    border-bottom-right-radius: 4px;
  }
  
  /* Left-aligned messages (received) */
  .message-bubble.received {
    align-self: flex-start;
    background: var(--bubble-left, #2d3748);
    color: var(--text, #e8eaed);
    border-bottom-left-radius: 4px;
  }
  
  /* System messages */
  .message-bubble.system {
    align-self: center;
    background: rgba(255,255,255,0.1);
    color: var(--muted);
    font-style: italic;
    font-size: 13px;
    border-radius: 16px;
    padding: 6px 12px;
    max-width: 80%;
    text-align: center;
  }

  /* Message Header */
  .message-header {
    display: flex; 
    justify-content: space-between; 
    align-items: baseline; 
    margin-bottom: 4px;
    gap: 12px;
  }
  
  .message-sender { 
    font-weight: 600; 
    font-size: 13px;
    color: var(--accent, #25d366);
    flex-shrink: 0;
  }
  
  .sent .message-sender {
    color: rgba(255,255,255,0.9);
  }
  
  .message-time { 
    color: rgba(255,255,255,0.7); 
    font-size: 11px; 
    flex-shrink: 0;
    font-weight: 400;
  }
  
  .received .message-time {
    color: var(--muted, #a0a0a0);
  }
  
  /* Message Text */
  .message-text { 
    white-space: pre-wrap; 
    line-height: 1.4;
    font-size: 14px;
    margin: 0;
  }
  
  .message-text:empty {
    display: none;
  }

  /* Hide system message header */
  .system .message-header {
    display: none;
  }
  
  .system .message-text {
    font-size: 13px;
    text-align: center;
  }

  /* WhatsApp-style Attachment Styles */
  .message-attachments {
    margin-top: 6px;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  
  /* Image Attachments */
  .attachment-images {
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
    margin-top: 4px;
  }
  
  .attachment-thumb { 
    max-width: 220px;
    max-height: 220px;
    min-width: 100px;
    min-height: 100px;
    border-radius: 8px; 
    display: block;
    cursor: pointer;
    transition: transform 0.2s ease;
    object-fit: cover;
    background: rgba(255,255,255,0.1);
  }
  
  .attachment-thumb:hover {
    transform: scale(1.05);
  }
  
  /* Single image can be larger */
  .attachment-images:has(:only-child) .attachment-thumb {
    max-width: 280px;
    max-height: 280px;
  }
  
  /* Video Attachments */
  .attachment-videos {
    margin-top: 4px;
  }
  
  .attachment-video { 
    max-width: 320px;
    max-height: 240px;
    width: 100%;
    border-radius: 8px;
    background: rgba(0,0,0,0.8);
  }
  
  /* Hide fullscreen button from thumbnail videos */
  .attachment-video::-webkit-media-controls-fullscreen-button {
    display: none !important;
  }
  
  .attachment-video::-moz-media-controls-fullscreen-button {
    display: none !important;
  }
  
  /* Audio Attachments */
  .attachment-audios {
    margin-top: 4px;
  }
  
  .attachment-audio { 
    max-width: 250px;
    width: 100%;
    height: 32px;
  }
  
  /* Document Attachments */
  .attachment-docs {
    margin-top: 4px;
  }
  
  .attachment-doc {
    display: inline-flex; 
    align-items: center; 
    gap: 8px; 
    padding: 8px 12px; 
    border-radius: 8px; 
    background: rgba(255,255,255,0.1); 
    color: var(--text);
    text-decoration: none;
    font-size: 13px;
    transition: background-color 0.2s ease;
    max-width: 200px;
    overflow: hidden;
  }
  
  .attachment-doc:hover {
    background: rgba(255,255,255,0.15);
    color: var(--text);
  }
  
  .attachment-doc::before {
    content: "📄";
    font-size: 16px;
    flex-shrink: 0;
  }
  
  /* Missing File Styles */
  .attachment-missing {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    background: rgba(244,67,54,0.2);
    border-radius: 6px;
    font-size: 12px;
    color: #ff9999;
  }
  
  .missing-badge { 
    display: inline-block; 
    font-size: 10px; 
    color: #fff; 
    background: #f44336; 
    padding: 2px 6px; 
    border-radius: 8px;
    font-weight: 500;
  }
  
  /* Media with text adjustments */
  .message-bubble:has(.message-attachments) .message-text:not(:empty) {
    margin-bottom: 4px;
  }
  
  /* Attachment-only messages */
  .message-bubble:has(.message-attachments) .message-text:empty + .message-attachments {
    margin-top: 0;
  }

  /* Legacy bubble styles (hidden for now) */
  .bubble { display: none; }
  .meta { display: none; }
  .sender { display: none; }
  .time { display: none; }
  .text { display: none; }
  .attachments { display: none; }
  .thumb { display: none; }
  .av { display: none; }
  .doc { display: none; }
  .badge-missing { display: none; }
  .system { display: none; }
  .sep { display: none; }

  /* Lightbox (optional nice-to-have) */
  .lightbox {
    position: fixed; inset: 0; background: rgba(0,0,0,.85);
    display:none; place-items: center; z-index: 50; padding: 10px;
  }
  .lightbox.show { display: grid; }
  .lightbox-content { max-width: 96vw; max-height: 90vh; }
  .lightbox video, .lightbox img { max-width: 100%; max-height: 90vh; border-radius: 10px; }

  /* Footer note */
  footer { padding: 8px 10px 12px; color: var(--muted); font-size: 12px; text-align: center; }

  .tools-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px;
  }
  
  .mini-btn { 
    padding: 10px 16px; 
    border-radius: 8px; 
    border: 1px solid #2a3a4b; 
    background: rgba(22, 32, 42, 0.8); 
    color: var(--ink); 
    cursor: pointer; 
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
    text-align: center;
  }
  
  .mini-btn:hover { 
    border-color: #3b5168; 
    background: rgba(26, 37, 47, 0.9);
    transform: translateY(-1px);
  }
  
  .dropzone {
    background: linear-gradient(135deg, rgba(13, 20, 27, 0.4), rgba(22, 32, 42, 0.4));
    border: 2px dashed #2a3a4b;
    border-radius: 16px;
    padding: 24px;
    text-align: center;
    color: var(--muted);
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
  }
  
  .dropzone:hover, .dropzone.drag {
    border-color: var(--primary);
    background: linear-gradient(135deg, rgba(37, 211, 102, 0.1), rgba(22, 32, 42, 0.6));
    color: var(--ink);
  }
  .unparsed-box { display:none; background:#0d141b; border:1px solid #2a3a4b; padding:8px; border-radius:8px; margin-top:6px; white-space: pre-wrap; }
</style>
</head>
<body>
  <header>
    <div class="control-panel" id="controlPanel">
      <div class="panel-header" id="panelHeader">
        <div class="panel-title">
          <h1 class="title">WhatsApp Chat Viewer</h1>
          <span class="filename-display" id="fileName">No file chosen</span>
        </div>
        <button class="minimize-btn" id="minimizeBtn">
          <span id="minimizeIcon">⌄</span>
          <span id="minimizeText">Minimize</span>
        </button>
      </div>
      
      <div class="panel-content" id="panelContent">
        <div class="section">
          <div class="section-title">File Import</div>
          <div class="file-section">
            <label class="file-btn" id="chooseBtn">
              Choose ZIP
              <input id="fileInput" type="file" accept=".zip" />
            </label>
            <div id="dropzone" class="dropzone">
              Drop WhatsApp export .zip here (kept local, never uploaded)
            </div>
          </div>
        </div>

        <div class="section">
          <div class="section-title">Search & Filter</div>
          <div class="filter-grid">
            <input id="filterInput" class="filter-input" placeholder="Filter by keyword (sender or text)…" />
            <select id="typeFilter" class="type-filter" title="Filter by message type">
              <option value="">All Types</option>
              <option value="text">Text Only</option>
              <option value="image">Images</option>
              <option value="video">Videos</option>
              <option value="audio">Audio</option>
              <option value="doc">Documents</option>
              <option value="mixed">Mixed Media</option>
            </select>
            <input id="extFilter" class="ext-filter" placeholder="File extension" title="Filter by file extension (e.g. jpg, pdf)" />
          </div>
        </div>

        <div class="section">
          <div class="section-title">Navigation</div>
          <div class="date-nav">
            <button id="backWeek" class="date-nav-btn" title="Go back 1 week">◀◀</button>
            <button id="back3Days" class="date-nav-btn" title="Go back 3 days">◀</button>
            <div class="date-control">
              <span id="currentDate" class="current-date-btn" title="Click to enter specific date">-</span>
              <div id="dateInputPanel" class="date-input-panel" style="display: none;">
                <input id="jumpDate" class="jump-date-input" type="date" title="Select date from calendar" />
                <div class="date-input-buttons">
                  <button id="jumpGoBtn" class="date-input-btn" title="Jump to date">Go</button>
                  <button id="jumpCancelBtn" class="date-input-btn cancel" title="Cancel">✕</button>
                </div>
              </div>
            </div>
            <button id="next3Days" class="date-nav-btn" title="Go forward 3 days">▶</button>
            <button id="nextWeek" class="date-nav-btn" title="Go forward 1 week">▶▶</button>
          </div>
        </div>

        <div class="section">
          <div class="section-title">Advanced Options</div>
          <div class="tools-grid">
            <button id="toggleLoose" class="mini-btn" title="Looser parsing mode for quirky exports">Loose Parsing: OFF</button>
            <button id="showUnparsed" class="mini-btn">Show Unparsed Sample</button>
          </div>
        </div>

        <div class="section">
          <div id="stats" class="stats" aria-live="polite"></div>
          <div id="progress" class="progress" aria-live="polite"></div>
          <div id="progressBarContainer" class="progress-bar-container">
            <div id="progressBar" class="progress-bar"></div>
          </div>
          <div id="unparsedBox" class="unparsed-box"></div>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div id="chat" class="chat" role="list"></div>
  </main>

  <footer>
    Built for local use. Uses <a href="https://github.com/101arrowz/fflate" target="_blank" rel="noreferrer">fflate</a> to read ZIPs in the browser. No data leaves your device.
  </footer>

  <!-- Lightbox -->
  <div id="lightbox" class="lightbox" tabindex="0" aria-modal="true" role="dialog">
    <div class="lightbox-content" id="lightboxContent"></div>
  </div>

  <!-- Only allowed external script -->
  <script src="https://cdn.jsdelivr.net/npm/fflate/umd/index.js"></script>
  <script>
  (function () {
    /*** Android ListView Pattern Implementation ***/
    
    // Data Source Layer - Manages all message data
    class ChatDataSource {
      constructor() {
        this.messages = [];
        this.filtered = [];
        this.observers = [];
        this.dateIndex = new Map(); // date -> array of positions
        this.idIndex = new Map();   // id -> position
      }
      
      setMessages(messages) {
        this.messages = messages.map((msg, index) => ({
          ...msg,
          id: this.generateStableId(msg, index),
          originalIndex: index
        }));
        this.filtered = [...this.messages];
        this.rebuildIndexes();
        this.notifyDataSetChanged();
      }
      
      generateStableId(msg, index) {
        // Create stable ID from content hash + timestamp
        const content = (msg.text || '') + (msg.sender || '') + (msg.iso || index);
        return this.hashCode(content);
      }
      
      hashCode(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32-bit integer
        }
        return Math.abs(hash);
      }
      
      rebuildIndexes() {
        this.dateIndex.clear();
        this.idIndex.clear();
        
        this.filtered.forEach((msg, position) => {
          // Index by date
          if (msg.date) {
            const dateKey = this.getDateKey(msg.date);
            if (!this.dateIndex.has(dateKey)) {
              this.dateIndex.set(dateKey, []);
            }
            this.dateIndex.get(dateKey).push(position);
          }
          
          // Index by ID
          this.idIndex.set(msg.id, position);
        });
      }
      
      getDateKey(date) {
        return date.toISOString().split('T')[0]; // YYYY-MM-DD
      }
      
      applyFilter(predicate) {
        this.filtered = this.messages.filter(predicate);
        this.rebuildIndexes();
        this.notifyDataSetChanged();
      }
      
      getCount() {
        return this.filtered.length;
      }
      
      getItem(position) {
        return this.filtered[position];
      }
      
      getItemId(position) {
        const item = this.getItem(position);
        return item ? item.id : position;
      }
      
      findPositionByDate(targetDate) {
        const targetKey = this.getDateKey(targetDate);
        const positions = this.dateIndex.get(targetKey);
        return positions && positions.length > 0 ? positions[0] : -1;
      }
      
      findPositionNearDate(targetDate) {
        let bestPosition = -1;
        let minDiff = Infinity;
        
        for (let i = 0; i < this.filtered.length; i++) {
          const msg = this.filtered[i];
          if (!msg.date) continue;
          
          const diff = Math.abs(msg.date.getTime() - targetDate.getTime());
          if (diff < minDiff) {
            minDiff = diff;
            bestPosition = i;
          }
        }
        
        return bestPosition;
      }
      
      registerObserver(observer) {
        this.observers.push(observer);
      }
      
      unregisterObserver(observer) {
        const index = this.observers.indexOf(observer);
        if (index > -1) {
          this.observers.splice(index, 1);
        }
      }
      
      notifyDataSetChanged() {
        this.observers.forEach(observer => {
          if (observer.onDataSetChanged) {
            observer.onDataSetChanged();
          }
        });
      }
    }

    // Adapter Layer - Bridges data and views
    class ChatAdapter {
      constructor(dataSource) {
        this.dataSource = dataSource;
        this.recycledViews = new Map(); // viewType -> array of views
        this.viewTypes = {
          TEXT: 0,
          IMAGE: 1,
          VIDEO: 2,
          AUDIO: 3,
          DOCUMENT: 4,
          SYSTEM: 5
        };
      }
      
      getCount() {
        return this.dataSource.getCount();
      }
      
      getItem(position) {
        return this.dataSource.getItem(position);
      }
      
      getItemId(position) {
        return this.dataSource.getItemId(position);
      }
      
      getItemViewType(position) {
        const item = this.getItem(position);
        if (!item) return this.viewTypes.TEXT;
        
        if (!item.sender) return this.viewTypes.SYSTEM;
        
        if (item.attachments && item.attachments.length > 0) {
          const hasImage = item.attachments.some(name => this.isImageFile(name));
          const hasVideo = item.attachments.some(name => this.isVideoFile(name));
          const hasAudio = item.attachments.some(name => this.isAudioFile(name));
          
          if (hasImage) return this.viewTypes.IMAGE;
          if (hasVideo) return this.viewTypes.VIDEO;
          if (hasAudio) return this.viewTypes.AUDIO;
          return this.viewTypes.DOCUMENT;
        }
        
        return this.viewTypes.TEXT;
      }
      
      isImageFile(filename) {
        const ext = filename.toLowerCase().split('.').pop();
        return ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'].includes(ext);
      }
      
      isVideoFile(filename) {
        const ext = filename.toLowerCase().split('.').pop();
        return ['mp4', 'webm', 'mov', 'avi', 'mkv', '3gp'].includes(ext);
      }
      
      isAudioFile(filename) {
        const ext = filename.toLowerCase().split('.').pop();
        return ['mp3', 'wav', 'ogg', 'm4a', 'aac', 'opus'].includes(ext);
      }
      
      getView(position, convertView, parent) {
        const viewType = this.getItemViewType(position);
        const item = this.getItem(position);
        
        // Try to reuse existing view of same type
        let view = this.getRecycledView(viewType);
        if (!view) {
          view = this.createView(viewType);
        }
        
        // Bind data to view
        this.bindView(view, item, position);
        
        return view;
      }
      
      createView(viewType) {
        const view = document.createElement('div');
        view.className = 'list-item';
        view.setAttribute('role', 'listitem');
        view.dataset.viewType = viewType;
        
        if (viewType === this.viewTypes.SYSTEM) {
          // System message layout
          view.innerHTML = `
            <div class="message-bubble system">
              <div class="message-header">
                <span class="message-time"></span>
              </div>
              <div class="message-text"></div>
            </div>
          `;
        } else {
          // Regular message bubble layout
          view.innerHTML = `
            <div class="message-bubble">
              <div class="message-header">
                <span class="message-sender"></span>
                <span class="message-time"></span>
              </div>
              <div class="message-text"></div>
              <div class="message-attachments">
                <div class="attachment-images"></div>
                <div class="attachment-videos"></div>
                <div class="attachment-audios"></div>
                <div class="attachment-docs"></div>
              </div>
            </div>
          `;
        }
        
        return view;
      }
      
      bindView(view, item, position) {
        if (!item) return;
        
        // Update data attributes
        view.dataset.position = position;
        view.dataset.messageId = item.id;
        view.dataset.originalIndex = item.originalIndex;
        
        const bubble = view.querySelector('.message-bubble');
        const sender = view.querySelector('.message-sender');
        const time = view.querySelector('.message-time');
        const textEl = view.querySelector('.message-text');
        
        // Determine message alignment (sent vs received)
        const isSystemMessage = !item.sender;
        if (!isSystemMessage && bubble) {
          const isSent = this.isMessageSent(item.sender);
          bubble.className = isSent ? 'message-bubble sent' : 'message-bubble received';
        }
        
        // Update sender and time
        if (sender) sender.textContent = item.sender || 'System';
        if (time) time.textContent = this.formatTime(item.date, item.iso);
        
        // Update text content
        if (textEl) {
          textEl.textContent = item.text || '';
          if (item.text && this.isRTL(item.text)) {
            textEl.setAttribute('dir', 'rtl');
          } else {
            textEl.removeAttribute('dir');
          }
        }
        
        // Handle attachments
        this.bindAttachments(view, item);
        
        // Hide empty attachment containers
        this.hideEmptyAttachmentContainers(view);
      }
      
      isMessageSent(sender) {
        // Determine if message is sent by the main user
        // In WhatsApp exports, typically the second participant is the main user
        if (participantsOrder.length >= 2) {
          return sender === participantsOrder[1];
        }
        // Fallback: if only one participant, assume they're the main user
        return participantsOrder.length === 1 && sender === participantsOrder[0];
      }
      
      hideEmptyAttachmentContainers(view) {
        const attachmentContainers = view.querySelectorAll('.attachment-images, .attachment-videos, .attachment-audios, .attachment-docs');
        attachmentContainers.forEach(container => {
          container.style.display = container.children.length > 0 ? 'flex' : 'none';
        });
        
        // Hide main attachment container if all sub-containers are empty
        const mainContainer = view.querySelector('.message-attachments');
        if (mainContainer) {
          const hasAnyAttachments = Array.from(attachmentContainers).some(container => container.children.length > 0);
          mainContainer.style.display = hasAnyAttachments ? 'flex' : 'none';
        }
      }
      
      bindAttachments(view, item) {
        // Clear existing attachments
        const attachmentContainers = view.querySelectorAll('.attachment-images, .attachment-videos, .attachment-audios, .attachment-docs');
        attachmentContainers.forEach(container => container.innerHTML = '');
        
        if (!item.attachments || item.attachments.length === 0) {
          return;
        }
        
        for (const attachmentName of item.attachments) {
          const base = this.getBaseName(attachmentName);
          const full = fileIndexByBase[base]; // Legacy reference
          
          if (!full) {
            this.createMissingAttachment(view, base);
            continue;
          }
          
          if (this.isImageFile(base)) {
            this.createImageAttachment(view, base);
          } else if (this.isVideoFile(base)) {
            this.createVideoAttachment(view, base);
          } else if (this.isAudioFile(base)) {
            this.createAudioAttachment(view, base);
          } else {
            this.createDocumentAttachment(view, base);
          }
        }
      }
      
      createImageAttachment(view, filename) {
        const container = view.querySelector('.attachment-images');
        if (!container) return;
        
        const img = document.createElement('img');
        img.className = 'attachment-thumb';
        img.loading = 'lazy';
        img.alt = filename;
        img.dataset.src = this.getFileURL(filename); // Lazy loading
        img.addEventListener('click', () => this.openLightbox('img', this.getFileURL(filename), filename));
        
        // Use intersection observer for lazy loading
        this.setupLazyLoading(img);
        container.appendChild(img);
      }
      
      createVideoAttachment(view, filename) {
        const container = view.querySelector('.attachment-videos');
        if (!container) return;
        
        const video = document.createElement('video');
        video.className = 'attachment-video';
        video.controls = true;
        video.preload = 'metadata';
        video.src = this.getFileURL(filename);
        video.dataset.filename = filename; // Store filename for sync
        video.style.cssText = `
          max-width: 320px;
          max-height: 240px;
          width: auto;
          height: auto;
          border-radius: 8px;
        `;
        video.addEventListener('click', (e) => { 
          e.preventDefault();
          // Get current video state
          const currentTime = video.currentTime || 0;
          const wasPaused = video.paused;
          // Pause thumbnail video
          if (!video.paused) video.pause();
          // Open lightbox with current state
          this.openLightboxWithState('video', this.getFileURL(filename), filename, currentTime, wasPaused);
        });
        container.appendChild(video);
      }
      
      createAudioAttachment(view, filename) {
        const container = view.querySelector('.attachment-audios');
        if (!container) return;
        
        const audio = document.createElement('audio');
        audio.className = 'attachment-audio';
        audio.controls = true;
        audio.preload = 'metadata';
        audio.src = this.getFileURL(filename);
        container.appendChild(audio);
      }
      
      createDocumentAttachment(view, filename) {
        const container = view.querySelector('.attachment-docs');
        if (!container) return;
        
        const link = document.createElement('a');
        link.className = 'attachment-doc';
        link.href = this.getFileURL(filename);
        link.download = filename;
        link.target = '_blank';
        link.rel = 'noreferrer';
        link.textContent = filename;
        container.appendChild(link);
      }
      
      createMissingAttachment(view, filename) {
        // Add missing files to the most appropriate container or create a general one
        const container = view.querySelector('.attachment-docs') || 
                         view.querySelector('.message-attachments');
        if (!container) return;
        
        const missing = document.createElement('div');
        missing.className = 'attachment-missing';
        missing.innerHTML = `<span>${filename}</span><span class="missing-badge">missing file</span>`;
        container.appendChild(missing);
      }
      
      setupLazyLoading(img) {
        if ('IntersectionObserver' in window) {
          const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                img.src = img.dataset.src;
                observer.unobserve(img);
              }
            });
          }, { threshold: 0.1 });
          observer.observe(img);
        } else {
          img.src = img.dataset.src;
        }
      }
      
      getRecycledView(viewType) {
        if (!this.recycledViews.has(viewType)) {
          return null;
        }
        const views = this.recycledViews.get(viewType);
        return views.length > 0 ? views.pop() : null;
      }
      
      recycleView(view) {
        const viewType = parseInt(view.dataset.viewType);
        if (!this.recycledViews.has(viewType)) {
          this.recycledViews.set(viewType, []);
        }
        
        // Clean up the view before recycling
        view.remove();
        this.recycledViews.get(viewType).push(view);
      }
      
      // Helper methods (will be integrated with existing functions)
      getBaseName(filename) {
        return filename.split('/').pop();
      }
      
      getFileURL(filename) {
        // This will integrate with existing lazyURLFor function
        return lazyURLFor ? lazyURLFor(filename) : null;
      }
      
      formatTime(date, iso) {
        // This will integrate with existing formatTime function
        return formatTime ? formatTime(date, iso) : (date ? date.toLocaleTimeString() : '');
      }
      
      isRTL(text) {
        // This will integrate with existing isRTL function
        return isRTL ? isRTL(text) : false;
      }
      
      openLightbox(kind, url, label) {
        // This will integrate with existing openLightbox function
        if (openLightbox) {
          openLightbox(kind, url, label);
        }
      }
      
      openLightboxWithState(kind, url, label, currentTime, wasPaused) {
        // This will integrate with existing openLightboxWithState function
        if (window.openLightboxWithState) {
          window.openLightboxWithState(kind, url, label, currentTime, wasPaused);
        } else if (openLightbox) {
          // Fallback to regular lightbox
          openLightbox(kind, url, label);
        }
      }
    }

    // ListView Layer - Handles rendering and virtual scrolling
    class ListView {
      constructor(container, adapter) {
        this.container = container;
        this.adapter = adapter;
        this.visibleRange = { start: 0, end: 0 };
        this.activeViews = new Map(); // position -> view element
        this.itemHeights = new Map(); // position -> measured height
        this.estimatedItemHeight = 50; // Default estimated height for WhatsApp-style messages
        this.scrollTop = 0;
        this.containerHeight = 0;
        this.totalHeight = 0;
        this.buffer = 5; // Extra items to render outside viewport
        
        this.init();
      }
      
      init() {
        // Set up container
        this.container.style.position = 'relative';
        this.container.style.overflowY = 'auto';
        
        // Create flexbox-friendly viewport structure
        this.viewport = document.createElement('div');
        this.viewport.style.display = 'flex';
        this.viewport.style.flexDirection = 'column';
        this.viewport.style.width = '100%';
        this.viewport.style.boxSizing = 'border-box';
        this.viewport.style.minHeight = '100%';
        
        // Create spacer for maintaining scroll position (not used in new approach)
        this.spacer = document.createElement('div');
        this.spacer.style.width = '100%';
        this.spacer.style.pointerEvents = 'none';
        this.spacer.style.height = '0px';
        
        this.container.appendChild(this.viewport);
        
        // Register data observer
        this.adapter.dataSource.registerObserver({
          onDataSetChanged: () => this.notifyDataSetChanged()
        });
        
        // Set up scroll listener
        this.container.addEventListener('scroll', () => this.onScroll());
        
        // Set up resize observer
        if ('ResizeObserver' in window) {
          this.resizeObserver = new ResizeObserver(() => {
            this.containerHeight = this.container.clientHeight;
            this.updateVisibleRange();
            this.render();
          });
          this.resizeObserver.observe(this.container);
        }
        
        // Initial setup
        this.containerHeight = this.container.clientHeight;
        this.updateTotalHeight();
        this.updateVisibleRange();
        this.render();
      }
      
      onScroll() {
        this.scrollTop = this.container.scrollTop;
        this.updateVisibleRange();
        this.render();
      }
      
      updateTotalHeight() {
        const count = this.adapter.getCount();
        let totalHeight = 0;
        
        for (let i = 0; i < count; i++) {
          const measuredHeight = this.itemHeights.get(i);
          totalHeight += measuredHeight || this.estimatedItemHeight;
        }
        
        this.totalHeight = totalHeight;
        this.spacer.style.height = `${this.totalHeight}px`;
      }
      
      getItemTop(position) {
        let top = 0;
        for (let i = 0; i < position; i++) {
          const height = this.itemHeights.get(i) || this.estimatedItemHeight;
          top += height;
        }
        return top;
      }
      
      updateVisibleRange() {
        const count = this.adapter.getCount();
        if (count === 0) {
          this.visibleRange = { start: 0, end: -1 };
          return;
        }
        
        // Binary search to find start position
        let start = 0;
        let end = count - 1;
        
        while (start < end) {
          const mid = Math.floor((start + end) / 2);
          const itemTop = this.getItemTop(mid);
          
          if (itemTop < this.scrollTop) {
            start = mid + 1;
          } else {
            end = mid;
          }
        }
        
        // Find end position
        let endPos = start;
        let currentTop = this.getItemTop(start);
        const viewportBottom = this.scrollTop + this.containerHeight;
        
        while (endPos < count && currentTop < viewportBottom) {
          const height = this.itemHeights.get(endPos) || this.estimatedItemHeight;
          currentTop += height;
          endPos++;
        }
        
        // Apply buffer
        this.visibleRange.start = Math.max(0, start - this.buffer);
        this.visibleRange.end = Math.min(count - 1, endPos - 1 + this.buffer);
      }
      
      render() {
        const { start, end } = this.visibleRange;
        
        // Remove views that are no longer visible
        const viewsToRemove = [];
        for (const [position, view] of this.activeViews.entries()) {
          if (position < start || position > end) {
            viewsToRemove.push(position);
            this.adapter.recycleView(view);
            view.remove();
          }
        }
        viewsToRemove.forEach(pos => this.activeViews.delete(pos));
        
        // Clear viewport and rebuild visible items in order
        this.viewport.innerHTML = '';
        
        // Add visible views in order to maintain proper flexbox flow
        for (let position = start; position <= end; position++) {
          let view = this.activeViews.get(position);
          
          if (!view) {
            view = this.adapter.getView(position, null, this.viewport);
            this.activeViews.set(position, view);
          }
          
          // Use flexbox-friendly positioning
          view.style.position = 'static';
          view.style.width = '100%';
          view.style.marginBottom = '8px';
          
          this.viewport.appendChild(view);
          
          // Measure height after rendering
          this.measureItemHeight(position, view);
        }
        
        // Update spacer height for proper scrollbar
        this.updateScrollPadding();
      }
      
      measureItemHeight(position, view) {
        // Use requestAnimationFrame to ensure DOM is updated
        requestAnimationFrame(() => {
          const height = view.offsetHeight;
          const previousHeight = this.itemHeights.get(position);
          
          if (height > 0 && height !== previousHeight) {
            this.itemHeights.set(position, height);
            
            // Update estimated height based on measured heights
            this.updateEstimatedHeight();
            
            // Recalculate total height and re-render if height changed significantly
            if (!previousHeight || Math.abs(height - previousHeight) > 5) {
              this.updateTotalHeight();
              this.updateVisibleRange();
              this.render();
            }
          }
        });
      }
      
      updateEstimatedHeight() {
        if (this.itemHeights.size === 0) return;
        
        const heights = Array.from(this.itemHeights.values());
        const average = heights.reduce((sum, h) => sum + h, 0) / heights.length;
        this.estimatedItemHeight = Math.max(35, Math.round(average)); // Minimum 35px for WhatsApp messages
      }
      
      updateScrollPadding() {
        const { start, end } = this.visibleRange;
        const count = this.adapter.getCount();
        
        // Calculate padding before visible range
        let paddingTop = 0;
        for (let i = 0; i < start; i++) {
          paddingTop += this.itemHeights.get(i) || this.estimatedItemHeight;
        }
        
        // Calculate padding after visible range
        let paddingBottom = 0;
        for (let i = end + 1; i < count; i++) {
          paddingBottom += this.itemHeights.get(i) || this.estimatedItemHeight;
        }
        
        // Apply padding to maintain virtual scrolling effect
        this.viewport.style.paddingTop = `${paddingTop}px`;
        this.viewport.style.paddingBottom = `${paddingBottom}px`;
      }
      
      scrollToPosition(position, alignment = 'start') {
        if (position < 0 || position >= this.adapter.getCount()) {
          return;
        }
        
        const itemTop = this.getItemTop(position);
        let scrollTop;
        
        switch (alignment) {
          case 'center':
            const itemHeight = this.itemHeights.get(position) || this.estimatedItemHeight;
            scrollTop = itemTop - (this.containerHeight - itemHeight) / 2;
            break;
          case 'end':
            scrollTop = itemTop - this.containerHeight + (this.itemHeights.get(position) || this.estimatedItemHeight);
            break;
          default: // 'start'
            scrollTop = itemTop;
        }
        
        scrollTop = Math.max(0, Math.min(scrollTop, this.totalHeight - this.containerHeight));
        this.container.scrollTop = scrollTop;
      }
      
      scrollToPositionSmooth(position, alignment = 'start') {
        if (position < 0 || position >= this.adapter.getCount()) {
          return;
        }
        
        const itemTop = this.getItemTop(position);
        let targetScrollTop;
        
        switch (alignment) {
          case 'center':
            const itemHeight = this.itemHeights.get(position) || this.estimatedItemHeight;
            targetScrollTop = itemTop - (this.containerHeight - itemHeight) / 2;
            break;
          case 'end':
            targetScrollTop = itemTop - this.containerHeight + (this.itemHeights.get(position) || this.estimatedItemHeight);
            break;
          default: // 'start'
            targetScrollTop = itemTop;
        }
        
        targetScrollTop = Math.max(0, Math.min(targetScrollTop, this.totalHeight - this.containerHeight));
        
        // Smooth scroll animation
        const startScrollTop = this.container.scrollTop;
        const distance = targetScrollTop - startScrollTop;
        const duration = 500; // ms
        const startTime = performance.now();
        
        const animateScroll = (currentTime) => {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          // Easing function (ease-out)
          const easeOut = 1 - Math.pow(1 - progress, 3);
          
          this.container.scrollTop = startScrollTop + distance * easeOut;
          
          if (progress < 1) {
            requestAnimationFrame(animateScroll);
          }
        };
        
        requestAnimationFrame(animateScroll);
      }
      
      highlightItem(position, duration = 2000) {
        const view = this.activeViews.get(position);
        if (view) {
          view.classList.add('highlighted');
          setTimeout(() => {
            view.classList.remove('highlighted');
          }, duration);
        }
      }
      
      notifyDataSetChanged() {
        // Clear cached heights as data may have changed
        this.itemHeights.clear();
        
        // Clear active views
        for (const view of this.activeViews.values()) {
          this.adapter.recycleView(view);
        }
        this.activeViews.clear();
        
        // Recalculate everything
        this.updateTotalHeight();
        this.updateVisibleRange();
        this.render();
      }
      
      getVisibleRange() {
        return { ...this.visibleRange };
      }
      
      getItemCount() {
        return this.adapter.getCount();
      }
      
      destroy() {
        if (this.resizeObserver) {
          this.resizeObserver.disconnect();
        }
        
        this.adapter.dataSource.unregisterObserver(this);
        
        for (const view of this.activeViews.values()) {
          this.adapter.recycleView(view);
        }
        this.activeViews.clear();
      }
    }

    /*** Integration Layer - Connects ListView with existing code ***/
    
    // Global instances
    let dataSource;
    let adapter;
    let listView;
    
    function initializeListView() {
      dataSource = new ChatDataSource();
      adapter = new ChatAdapter(dataSource);
      listView = new ListView(chatEl, adapter);
      
      // Set up data observer for UI updates
      dataSource.registerObserver({
        onDataSetChanged: () => {
          updateStats();
          // Clear progress after a short delay to show completion
          setTimeout(() => setProgress(''), 2000);
        }
      });
    }
    
    function setMessagesInListView(messagesArray) {
      // Convert messages to have stable IDs and searchable text
      const processedMessages = messagesArray.map((msg, index) => ({
        ...msg,
        originalIndex: index,
        searchable: ((msg.sender||'') + ' ' + (msg.text||'') + 
                    (msg.attachments && msg.attachments.length ? (' ' + msg.attachments.join(' ')) : '')).toLowerCase()
      }));
      
      dataSource.setMessages(processedMessages);
    }
    
    function applyFilterToListView() {
      const q = (filterInput.value || '').toLowerCase().trim();
      const typeQ = typeFilter.value;
      const extQ = (extFilter.value || '').toLowerCase().trim();
      
      const filterPredicate = (m) => {
        // Text search filter
        if (q && !m.searchable.includes(q)) return false;
        
        // Message type filter  
        if (typeQ && m.messageType !== typeQ) return false;
        
        // File extension filter
        if (extQ && (!m.fileExtensions || !m.fileExtensions.some(ext => ext.includes(extQ)))) return false;
        
        return true;
      };
      
      dataSource.applyFilter(filterPredicate);
      
      // Save filters to sessionStorage
      try { 
        sessionStorage.setItem('whz_filter', filterInput.value);
        sessionStorage.setItem('whz_type_filter', typeFilter.value);
        sessionStorage.setItem('whz_ext_filter', extFilter.value);
      } catch {}
    }
    
    function jumpToDateInListView(targetDate) {
      if (!dataSource || !listView) return false;
      
      // Try exact date first
      let position = dataSource.findPositionByDate(targetDate);
      
      // If no exact match, find nearest date
      if (position === -1) {
        position = dataSource.findPositionNearDate(targetDate);
      }
      
      if (position !== -1) {
        listView.scrollToPositionSmooth(position, 'center');
        listView.highlightItem(position, 3000);
        
        // Update current date display
        const item = dataSource.getItem(position);
        if (item && item.date) {
          currentViewDate = new Date(item.date);
          updateCurrentDateDisplay();
        }
        return true;
      }
      
      return false;
    }

    /*** Legacy State (to be refactored) ***/
    let rawFiles = {};
    let fileIndexByBase = {};
    let activeURLs = new Set();
    let messages = []; // Will be replaced by dataSource
    let filtered = []; // Will be replaced by dataSource
    let participantsOrder = [];
    let unparsedLines = [];
    let looseMode = false;
    let currentViewDate = null;

    const CHUNK_SIZE = 250;

    /*** Elements ***/
    const fileInput = document.getElementById('fileInput');
    const chooseBtn = document.getElementById('chooseBtn');
    const dropzone = document.getElementById('dropzone');
    const fileNameEl = document.getElementById('fileName');
    const progressEl = document.getElementById('progress');
    const statsEl = document.getElementById('stats');
    const chatEl = document.getElementById('chat');
    const filterInput = document.getElementById('filterInput');
    const typeFilter = document.getElementById('typeFilter');
    const extFilter = document.getElementById('extFilter');
    const jumpDateInput = document.getElementById('jumpDate');
    const dateInputPanel = document.getElementById('dateInputPanel');
    const jumpGoBtn = document.getElementById('jumpGoBtn');
    const jumpCancelBtn = document.getElementById('jumpCancelBtn');
    const currentDateEl = document.getElementById('currentDate');
    const backWeekBtn = document.getElementById('backWeek');
    const back3DaysBtn = document.getElementById('back3Days');
    const next3DaysBtn = document.getElementById('next3Days');
    const nextWeekBtn = document.getElementById('nextWeek');
    const lightbox = document.getElementById('lightbox');
    const lightboxContent = document.getElementById('lightboxContent');
    const toggleLooseBtn = document.getElementById('toggleLoose');
    const showUnparsedBtn = document.getElementById('showUnparsed');
    const unparsedBox = document.getElementById('unparsedBox');

    /*** Utils ***/
    function resetState() {
      revokeAllURLs();
      rawFiles = {};
      fileIndexByBase = {};
      messages = [];
      filtered = [];
      participantsOrder = [];
      unparsedLines = [];
      currentViewDate = null;
      chatEl.innerHTML = '';
      statsEl.textContent = '';
      progressEl.textContent = '';
      unparsedBox.style.display = 'none';
      unparsedBox.textContent = '';
      updateCurrentDateDisplay();
    }

    function setProgress(msg, showSpinner = false, percentage = null) { 
      const progressBarContainer = document.getElementById('progressBarContainer');
      const progressBar = document.getElementById('progressBar');
      
      if (showSpinner && msg) {
        progressEl.innerHTML = '<span class="spinner"></span>' + msg;
      } else {
        progressEl.textContent = msg; 
      }
      
      if (percentage !== null) {
        progressBarContainer.style.display = 'block';
        progressBar.style.width = Math.min(100, Math.max(0, percentage)) + '%';
      } else if (!msg) {
        progressBarContainer.style.display = 'none';
        progressBar.style.width = '0%';
      }
    }
    
    // Helper functions for better progress reporting
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }
    
    function formatDuration(milliseconds) {
      if (milliseconds < 1000) return `${Math.round(milliseconds)}ms`;
      const seconds = Math.floor(milliseconds / 1000);
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      return `${minutes}m ${seconds % 60}s`;
    }
    
    let operationStartTime = 0;

    function revokeAllURLs() {
      for (const url of activeURLs) URL.revokeObjectURL(url);
      activeURLs.clear();
    }

    function isRTL(s) {
      const rtlRanges = [/[\u0590-\u05FF]/, /[\u0600-\u06FF]/, /[\u0750-\u077F]/, /[\u08A0-\u08FF]/];
      return rtlRanges.some(r => r.test(s));
    }

    function stripMarks(s) {
      // Remove LRM/RLM/ZW + embedding/override marks + NBSP that iOS often injects
      return s.replace(/[\u00A0\u200e\u200f\u202a-\u202e\u2066-\u2069]/g, '');
    }


    function parseTimestamp(dateStr, timeStr, ampmRaw) {
      if (!dateStr || !timeStr) return { date: null, iso: (dateStr||'') + ' ' + (timeStr||'') };

      const dsep = /[\/\.-]/;
      const parts = dateStr.split(dsep);
      if (parts.length < 3) return { date:null, iso: dateStr + ' ' + timeStr };
      let d = parseInt(parts[0],10), m = parseInt(parts[1],10) - 1, y = parseInt(parts[2],10);
      if (parts[2].length === 2) y += (y >= 70 ? 1900 : 2000);

      let hh=0, mm=0, ss=0;
      const mTime = timeStr.trim().match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?(?:\s*([AP]\.?M\.?))?$/i);
      if (mTime) {
        hh = parseInt(mTime[1],10);
        mm = parseInt(mTime[2],10);
        ss = mTime[3] ? parseInt(mTime[3],10) : 0;
        let ampm = (mTime[4] || ampmRaw || '').toUpperCase().replace(/\./g,'');
        if (ampm) {
          if (ampm === 'PM' && hh < 12) hh += 12;
          if (ampm === 'AM' && hh === 12) hh = 0;
        }
      } else {
        return { date:null, iso: dateStr + ' ' + timeStr };
      }
      const date = new Date(y, m, d, hh, mm, ss, 0);

      const iso = `${y.toString().padStart(4,'0')}-${(m+1).toString().padStart(2,'0')}-${d.toString().padStart(2,'0')} ${hh.toString().padStart(2,'0')}:${mm.toString().padStart(2,'0')}`;
      return isNaN(date.getTime()) ? ({ date:null, iso: dateStr + ' ' + timeStr }) : ({ date, iso });
    }

    // Core regexes (cover common exports):
    // Leading bidi/nbsp marks are stripped, but be tolerant anyway
    const RX_BRACKET = /^[\u200e\u200f\s]*\[(\d{1,2}[\/\.-]\d{1,2}[\/\.-]\d{2,4}),\s+(\d{1,2}:\d{2}(?::\d{2})?)(?:\s*([AP]\.?M\.?))?\]\s([^:]+?):\s([\s\S]*)$/i;
    const RX_DASH    = /^[\u200e\u200f\s]*(\d{1,2}[\/\.-]\d{1,2}[\/\.-]\d{2,4}),\s+(\d{1,2}:\d{2}(?::\d{2})?)(?:\s*([AP]\.?M\.?))?\s[-–—]\s([^:]+?):\s([\s\S]*)$/i;
    const RX_SYSTEM  = /^[\u200e\u200f\s]*(\d{1,2}[\/\.-]\d{1,2}[\/\.-]\d{2,4}),\s+(\d{1,2}:\d{2}(?::\d{2})?)(?:\s*([AP]\.?M\.?))?\s[-–—]\s([\s\S]+)$/i;


    // Attachment patterns: explicit placeholder <attached: NAME> OR implicit filename like IMG-*.jpg etc.
    const RX_ATTACHED_PLACEHOLDER = /[\u200e\u200f\u00A0]*<attached:\s*([^>]+?)>/gi;
    const RX_FILENAME_LIKE = /\b((?:IMG|VID|PTT|AUD|DOC|STK|WA|V|IMG-)\S+\.(?:jpg|jpeg|png|webp|gif|mp4|mov|webm|m4v|opus|m4a|mp3|ogg|wav|pdf|zip|docx|xlsx|pptx))\b/ig;

    function parseLine(line) {
      let L = stripMarks(line).trimEnd();

      // Try sender formats
      let m = L.match(RX_BRACKET);
      if (!m) m = L.match(RX_DASH);
      if (m) {
        const [, dateStr, timeStr, ampm, senderRaw, msgRaw] = m;
        const { date, iso } = parseTimestamp(dateStr, timeStr, ampm);
        const sender = senderRaw.trim();
        let text = msgRaw ?? '';

        const attachments = [];
        // explicit <attached: NAME>
        text = text.replace(RX_ATTACHED_PLACEHOLDER, (_, name) => {
          attachments.push(name.trim());
          return '';
        });

        // implicit filenames (only if loose mode enabled or no explicit placeholders)
        if (looseMode || attachments.length === 0) {
          const seen = new Set();
          text = text.replace(RX_FILENAME_LIKE, (fname) => {
            const base = fname.trim();
            if (!seen.has(base)) { attachments.push(base); seen.add(base); }
            return base; // keep the filename text visible too
          });
        }

        text = text.trim();
        return { date, iso, sender, text, attachments, raw: line };
      }

      // System-only message
      const s = L.match(RX_SYSTEM);
      if (s) {
        const [, dateStr, timeStr, ampm, rest] = s;
        const { date, iso } = parseTimestamp(dateStr, timeStr, ampm);
        let text = rest || '';
        const attachments = [];
        // Detect placeholders or filenames inside system message
        text = text.replace(RX_ATTACHED_PLACEHOLDER, (_, name) => { attachments.push(name.trim()); return ''; });
        if (looseMode || attachments.length === 0) {
          const seen = new Set();
          text = text.replace(RX_FILENAME_LIKE, (fname) => {
            const base = fname.trim();
            if (!seen.has(base)) { attachments.push(base); seen.add(base); }
            return base;
          });
        }
        return { date, iso, sender: '', text: text.trim(), attachments, raw: line };
      }

      return null; // continuation or unknown
    }

    function classifyMedia(name) {
      const n = name.toLowerCase();
      if (/\.(jpg|jpeg|png|webp|gif)$/.test(n)) return { kind: 'image', mime: `image/${n.endsWith('png')?'png':n.endsWith('gif')?'gif':n.endsWith('webp')?'webp':'jpeg'}` };
      if (/\.(mp4|mov|webm|m4v)$/.test(n)) return { kind: 'video', mime: n.endsWith('webm') ? 'video/webm' : (n.endsWith('mov') ? 'video/quicktime' : 'video/mp4') };
      if (/\.(opus|m4a|mp3|ogg|wav)$/.test(n)) return { kind: 'audio', mime: n.endsWith('mp3')?'audio/mpeg':n.endsWith('m4a')?'audio/mp4':n.endsWith('opus')?'audio/ogg; codecs=opus':n.endsWith('ogg')?'audio/ogg':n.endsWith('wav')?'audio/wav':'audio/*' };
      return { kind: 'doc', mime: 'application/octet-stream' };
    }

    function getMessageType(message) {
      // If no attachments, classify by text content
      if (!message.attachments || message.attachments.length === 0) {
        return message.text ? 'text' : 'system';
      }
      
      // If has attachments, classify by attachment types regardless of text
      const types = new Set();
      
      for (const attachment of message.attachments) {
        const base = getBaseName(attachment);
        const { kind } = classifyMedia(base);
        types.add(kind);
        
        // Debug logging for video files
        if (base.toLowerCase().includes('vid') || /\.(mp4|mov|webm|m4v)$/i.test(base)) {
          console.log('Video attachment detected:', { attachment, base, kind, messageText: message.text?.substring(0, 50) });
        }
      }
      
      if (types.size === 1) {
        const result = Array.from(types)[0];
        // Debug logging for video types
        if (result === 'video') {
          console.log('Message classified as video:', { attachments: message.attachments, types: Array.from(types), text: message.text?.substring(0, 50) });
        }
        return result; // 'image', 'video', 'audio', or 'doc'
      } else if (types.size > 1) {
        return 'mixed';
      }
      
      // Fallback - shouldn't reach here if attachments exist
      return message.text ? 'text' : 'system';
    }

    function getBaseName(path) {
      const i = path.lastIndexOf('/');
      const j = path.lastIndexOf('\\');
      const k = Math.max(i, j);
      return k >= 0 ? path.slice(k + 1) : path;
    }

    function lazyURLFor(name) {
      const base = getBaseName(name);
      const full = fileIndexByBase[base];
      if (!full) return null;
      const u8 = rawFiles[full];
      if (!u8) return null;
      const { mime } = classifyMedia(base);
      const blob = new Blob([u8], { type: mime });
      const url = URL.createObjectURL(blob);
      activeURLs.add(url);
      return url;
    }

    function pickChatTxt(filesMap) {
      let exact = null;
      let largest = null, largestSize = -1;
      for (const name of Object.keys(filesMap)) {
        const base = getBaseName(name);
        if (/^chat\.txt$/i.test(base)) { exact = name; break; }
        if (/\.txt$/i.test(base)) {
          const size = filesMap[name]?.length || 0;
          if (size > largestSize) { largest = name; largestSize = size; }
        }
      }
      return exact || largest;
    }

    function parseChatText(text) {
      messages = [];
      unparsedLines = [];
      participantsOrder = [];

      const lines = text.split(/\r?\n/);
      const totalLines = lines.length;
      let current = null;
      let lastProgressUpdate = 0;
      const parseStartTime = Date.now();

      setProgress(`Parsing transcript (${totalLines.toLocaleString()} lines)…`, true);

      for (let i = 0; i < lines.length; i++) {
        const rawLine = lines[i];
        if (!rawLine) continue;
        const line = rawLine; // keep for unparsed sample display
        
        // Update progress every 2000 lines or 100ms
        const now = Date.now();
        if (i % 2000 === 0 || now - lastProgressUpdate > 100) {
          const percentage = (i / totalLines) * 100;
          const elapsed = now - parseStartTime;
          const linesPerSec = elapsed > 0 ? Math.round((i / elapsed) * 1000) : 0;
          const eta = linesPerSec > 0 ? Math.round((totalLines - i) / linesPerSec * 1000) : 0;
          
          setProgress(`Parsing: ${i.toLocaleString()}/${totalLines.toLocaleString()} lines (${Math.round(percentage)}%) • ${linesPerSec.toLocaleString()}/sec${eta > 1000 ? ` • ETA ${formatDuration(eta)}` : ''}`, true, percentage);
          lastProgressUpdate = now;
        }

        const parsed = parseLine(line);
        if (parsed) {
          if (parsed.sender && !participantsOrder.includes(parsed.sender)) {
            participantsOrder.push(parsed.sender);
          }
          
          // Add message type and file extensions
          const messageType = getMessageType(parsed);
          const fileExtensions = [];
          if (parsed.attachments) {
            for (const attachment of parsed.attachments) {
              const base = getBaseName(attachment);
              const extMatch = base.match(/\.([^.]+)$/);
              if (extMatch) {
                const ext = extMatch[1].toLowerCase();
                if (!fileExtensions.includes(ext)) {
                  fileExtensions.push(ext);
                }
              }
            }
          }
          
          const searchable = ((parsed.sender||'') + ' ' + (parsed.text||'') + (parsed.attachments.length? (' ' + parsed.attachments.join(' ')) : '')).toLowerCase();
          messages.push({ ...parsed, searchable, messageType, fileExtensions });
          current = messages[messages.length - 1];
        } else {
          // continuation of previous message
          if (current) {
            current.text += '\\n' + stripMarks(line);
            current.searchable += ' ' + stripMarks(line).toLowerCase();
          } else {
            unparsedLines.push(line);
          }
        }
      }
      
      const parseElapsed = Date.now() - parseStartTime;
      const messagesPerSec = parseElapsed > 0 ? Math.round((messages.length / parseElapsed) * 1000) : 0;
      setProgress(`Parsed ${messages.length.toLocaleString()} messages in ${formatDuration(parseElapsed)} (${messagesPerSec.toLocaleString()}/sec)`, false, 100);
    }

    function formatTime(d, iso) {
      if (!d) return iso || '';
      const y = d.getFullYear();
      const m = (d.getMonth() + 1).toString().padStart(2, '0');
      const dd = d.getDate().toString().padStart(2, '0');
      const hh = d.getHours().toString().padStart(2, '0');
      const mm = d.getMinutes().toString().padStart(2, '0');
      return `${y}-${m}-${dd} ${hh}:${mm}`;
    }

    function sideFor(sender) {
      if (participantsOrder.length >= 2) {
        if (sender === participantsOrder[1]) return 'r';
        return '';
      } else if (participantsOrder.length === 1) {
        return '';
      }
      return '';
    }

    function makeBubble(msg, index) {
      const bubble = document.createElement('div');
      bubble.className = 'bubble ' + (msg.sender ? sideFor(msg.sender) : '');
      bubble.setAttribute('role', 'listitem');
      if (msg.text && isRTL(msg.text)) bubble.setAttribute('dir', 'rtl');

      const meta = document.createElement('div');
      meta.className = 'meta';
      const s = document.createElement('span'); s.className = 'sender'; s.textContent = msg.sender || 'System';
      const t = document.createElement('span'); t.className = 'time'; t.textContent = formatTime(msg.date, msg.iso);
      meta.appendChild(s); meta.appendChild(t);

      const textEl = document.createElement('div');
      textEl.className = 'text';
      textEl.textContent = msg.text || '';

      bubble.appendChild(meta);
      if (msg.text) bubble.appendChild(textEl);

      if (msg.attachments && msg.attachments.length) {
        const wrap = document.createElement('div');
        wrap.className = 'attachments';
        for (const name of msg.attachments) {
          const base = getBaseName(name);
          const full = fileIndexByBase[base];
          if (!full) {
            const miss = document.createElement('div');
            miss.className = 'doc';
            const sp = document.createElement('span'); sp.textContent = base + ' ';
            const badge = document.createElement('span'); badge.className='badge-missing'; badge.textContent='missing file';
            miss.appendChild(sp); miss.appendChild(badge);
            wrap.appendChild(miss);
            continue;
          }
          const { kind } = classifyMedia(base);
          const url = lazyURLFor(base);
          if (!url) {
            const miss = document.createElement('div');
            miss.className = 'doc';
            const sp = document.createElement('span'); sp.textContent = base + ' ';
            const badge = document.createElement('span'); badge.className='badge-missing'; badge.textContent='missing file';
            miss.appendChild(sp); miss.appendChild(badge);
            wrap.appendChild(miss);
            continue;
          }

          if (kind === 'image') {
            const img = document.createElement('img');
            img.className = 'thumb';
            img.loading = 'lazy';
            img.alt = base;
            img.src = url;
            img.addEventListener('click', () => openLightbox('img', url, base));
            wrap.appendChild(img);
          } else if (kind === 'video') {
            const v = document.createElement('video');
            v.className = 'av';
            v.controls = true;
            v.preload = 'metadata';
            v.src = url;
            v.addEventListener('click', () => { if (v.paused && v.currentTime === 0) openLightbox('video', url, base); });
            wrap.appendChild(v);
          } else if (kind === 'audio') {
            const a = document.createElement('audio');
            a.className = 'av';
            a.controls = true;
            a.preload = 'metadata';
            a.src = url;
            wrap.appendChild(a);
          } else {
            const a = document.createElement('a');
            a.className = 'doc';
            a.href = url; a.download = base; a.target = '_blank'; a.rel='noreferrer';
            a.textContent = base;
            wrap.appendChild(a);
          }
        }
        bubble.appendChild(wrap);
      }

      bubble.id = 'm-' + index;
      return bubble;
    }

    function openLightbox(kind, url, label) {
      openLightboxWithState(kind, url, label, 0, true);
    }
    
    function openLightboxWithState(kind, url, label, currentTime = 0, wasPaused = true) {
      lightboxContent.innerHTML = '';
      let node;
      if (kind === 'img') {
        node = document.createElement('img');
        node.src = url;
        node.alt = label;
      } else {
        node = document.createElement('video');
        node.src = url;
        node.controls = true;
        node.dataset.filename = label; // Store filename for reverse sync
        node.dataset.wasPaused = wasPaused;
        
        // Set up video with state
        node.addEventListener('loadedmetadata', () => {
          node.currentTime = currentTime;
          if (!wasPaused && currentTime > 0) {
            node.play().catch(() => {
              // Auto-play might be blocked, that's ok
            });
          }
        });
        
        // If metadata is already loaded
        if (node.readyState >= 1) {
          node.currentTime = currentTime;
          if (!wasPaused && currentTime > 0) {
            node.play().catch(() => {});
          }
        }
      }
      
      // Store reference for sync back
      window.currentLightboxVideo = kind === 'video' ? node : null;
      
      lightboxContent.appendChild(node);
      lightbox.classList.add('show');
      lightbox.focus();
    }
    
    // Make it globally available
    window.openLightboxWithState = openLightboxWithState;

    function closeLightbox() {
      const lightboxVideo = lightboxContent.querySelector('video');
      
      // Sync video state back to thumbnail before closing
      if (lightboxVideo && lightboxVideo.dataset.filename) {
        const filename = lightboxVideo.dataset.filename;
        const currentTime = lightboxVideo.currentTime || 0;
        const isPaused = lightboxVideo.paused;
        
        // Find the corresponding thumbnail video
        const thumbnailVideo = document.querySelector(`video[data-filename="${filename}"]`);
        if (thumbnailVideo) {
          // Sync state back to thumbnail and pause it
          if (thumbnailVideo.readyState >= 1) {
            thumbnailVideo.currentTime = currentTime;
            thumbnailVideo.pause(); // Always pause thumbnail when closing lightbox
          } else {
            // Wait for metadata to load
            thumbnailVideo.addEventListener('loadedmetadata', () => {
              thumbnailVideo.currentTime = currentTime;
              thumbnailVideo.pause(); // Always pause thumbnail when closing lightbox
            }, { once: true });
          }
        }
        
        // Pause lightbox video
        try { lightboxVideo.pause(); } catch {}
      }
      
      lightbox.classList.remove('show');
      lightboxContent.innerHTML = '';
      window.currentLightboxVideo = null;
    }

    lightbox.addEventListener('click', (e) => { if (e.target === lightbox || e.target === lightboxContent) closeLightbox(); });
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeLightbox(); });

    function updateStats() {
      let img=0, vid=0, aud=0, doc=0;
      for (const m of messages) {
        if (!m.attachments?.length) continue;
        for (const name of m.attachments) {
          const base = getBaseName(name);
          const full = fileIndexByBase[base];
          if (!full) continue;
          const { kind } = classifyMedia(base);
          if (kind === 'image') img++;
          else if (kind === 'video') vid++;
          else if (kind === 'audio') aud++;
          else doc++;
        }
      }
      const parts = [
        `<b>${messages.length}</b> messages`,
        img ? `<b>${img}</b> images` : null,
        vid ? `<b>${vid}</b> videos` : null,
        aud ? `<b>${aud}</b> audios` : null,
        doc ? `<b>${doc}</b> docs` : null,
        unparsedLines.length ? `<span title="Lines that didn’t match known formats"><b>${unparsedLines.length}</b> unparsed lines</span>` : null
      ].filter(Boolean);
      statsEl.innerHTML = parts.join(' · ');
    }

    function destroyChat() {
      revokeAllURLs();
      chatEl.innerHTML = '';
    }

    function renderMessages(list) {
      destroyChat();
      let lastDayKey = null;
      let i = 0;
      function step() {
        const frag = document.createDocumentFragment();
        for (let n = 0; n < CHUNK_SIZE && i < list.length; n++, i++) {
          const msg = list[i];
          const dayKey = msg.date ? (msg.date.getFullYear()+"-"+(msg.date.getMonth()+1).toString().padStart(2,'0')+"-"+msg.date.getDate().toString().padStart(2,'0')) : null;
          if (dayKey && dayKey !== lastDayKey) {
            const sep = document.createElement('div');
            sep.className = 'sep';
            sep.textContent = dayKey;
            frag.appendChild(sep);
            lastDayKey = dayKey;
          }
          // Use the actual index i (position in filtered list) for the ID
          frag.appendChild(makeBubble(msg, i));
        }
        chatEl.appendChild(frag);
        if (i < list.length) {
          requestAnimationFrame(step);
        } else {
          setProgress('');
        }
      }
      setProgress('Rendering messages…');
      requestAnimationFrame(step);
    }

    function applyFilter() {
      if (listView && dataSource) {
        // Use new ListView
        applyFilterToListView();
      } else {
        // Legacy fallback
        const q = (filterInput.value || '').toLowerCase().trim();
        const typeQ = typeFilter.value;
        const extQ = (extFilter.value || '').toLowerCase().trim();
        
        filtered = messages.filter(m => {
          // Text search filter
          if (q && !m.searchable.includes(q)) return false;
          
          // Message type filter
          if (typeQ && m.messageType !== typeQ) return false;
          
          // File extension filter
          if (extQ && (!m.fileExtensions || !m.fileExtensions.some(ext => ext.includes(extQ)))) return false;
          
          return true;
        });
        
        // Save filters to sessionStorage
        try { 
          sessionStorage.setItem('whz_filter', filterInput.value);
          sessionStorage.setItem('whz_type_filter', typeFilter.value);
          sessionStorage.setItem('whz_ext_filter', extFilter.value);
        } catch {}
        
        renderMessages(filtered);
      }
    }

    function updateCurrentDateDisplay() {
      if (currentViewDate) {
        const options = { year: 'numeric', month: 'short', day: 'numeric' };
        currentDateEl.textContent = currentViewDate.toLocaleDateString('en-US', options);
      } else {
        currentDateEl.textContent = '-';
      }
    }

    function jumpToDate(targetDate = null, direction = 'forward') {
      const val = targetDate || jumpDateInput.value;
      if (!val) return;
      
      const target = typeof val === 'string' ? new Date(val + 'T00:00:00') : val;
      if (isNaN(target.getTime())) return;
      
      if (listView && dataSource) {
        // Use new ListView
        const success = jumpToDateInListView(target);
        if (success) {
          currentViewDate = new Date(target);
          updateCurrentDateDisplay();
        }
        return;
      }
      
      let idx = -1;
      
      if (direction === 'forward') {
        // Find first message on or after target date
        idx = filtered.findIndex(m => m.date && m.date >= target);
        if (idx < 0) idx = filtered.length - 1;
      } else {
        // Find last message on or before target date
        for (let i = filtered.length - 1; i >= 0; i--) {
          if (filtered[i].date && filtered[i].date <= target) {
            idx = i;
            break;
          }
        }
        if (idx < 0) idx = 0; // If no messages before target, go to first message
      }
      
      // Get the message element using the filtered array index directly
      const messageId = 'm-' + idx;
      const messageEl = document.getElementById(messageId);
      if (!messageEl) {
        return;
      }
      
      // Add visual highlight to the target element temporarily
      messageEl.style.backgroundColor = 'rgba(58, 160, 255, 0.2)';
      messageEl.style.transition = 'background-color 0.5s ease';
      setTimeout(() => {
        messageEl.style.backgroundColor = '';
        setTimeout(() => messageEl.style.transition = '', 500);
      }, 2000);
      
      // Use scrollIntoView which works with the container hierarchy
      messageEl.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'start' 
      });
      
      // Small adjustment to account for padding
      setTimeout(() => {
        const mainEl = document.querySelector('main');
        if (mainEl) mainEl.scrollTop -= 20;
      }, 100);
      
      // Always update currentViewDate to the actual message date we jumped to
      if (filtered[idx] && filtered[idx].date) {
        currentViewDate = new Date(filtered[idx].date);
      }
      updateCurrentDateDisplay();
    }

    function navigateByDays(days) {
      if (!currentViewDate && filtered.length > 0) {
        // If no current date, start from the first message date
        const firstMsg = filtered.find(m => m.date);
        if (firstMsg) currentViewDate = new Date(firstMsg.date);
      }
      
      if (!currentViewDate) return;
      
      const newDate = new Date(currentViewDate);
      newDate.setDate(newDate.getDate() + days);
      
      // Use backward direction for negative days, forward for positive
      const direction = days < 0 ? 'backward' : 'forward';
      jumpToDate(newDate, direction);
    }

    filterInput.addEventListener('input', applyFilter);
    typeFilter.addEventListener('change', applyFilter);
    extFilter.addEventListener('input', applyFilter);
    
    // Date navigation event listeners
    let dateInputVisible = false;
    
    function showDateInput() {
      if (dateInputVisible) return;
      dateInputVisible = true;
      dateInputPanel.style.display = 'block';
      currentDateEl.style.opacity = '0.5';
      // Set current date as default if available
      if (currentViewDate) {
        const dateStr = currentViewDate.toISOString().split('T')[0];
        jumpDateInput.value = dateStr;
      }
      jumpDateInput.focus();
    }
    
    function hideDateInput() {
      if (!dateInputVisible) return;
      dateInputVisible = false;
      dateInputPanel.style.display = 'none';
      currentDateEl.style.opacity = '1';
      jumpDateInput.value = '';
    }
    
    function jumpToManualDate() {
      const dateStr = jumpDateInput.value;
      if (!dateStr) return;
      
      const target = new Date(dateStr + 'T00:00:00');
      if (isNaN(target.getTime())) {
        alert('Invalid date selected');
        return;
      }
      
      jumpToDate(target, 'forward');
      hideDateInput();
    }
    
    // Current date display - click to show date input panel
    currentDateEl.addEventListener('click', showDateInput);
    
    // Go button
    jumpGoBtn.addEventListener('click', jumpToManualDate);
    
    // Cancel button
    jumpCancelBtn.addEventListener('click', hideDateInput);
    
    // Date input - Enter to jump, Escape to cancel
    jumpDateInput.addEventListener('keypress', (e) => { 
      if (e.key === 'Enter') jumpToManualDate(); 
    });
    jumpDateInput.addEventListener('keydown', (e) => { 
      if (e.key === 'Escape') hideDateInput(); 
    });
    
    // Click outside to close panel
    document.addEventListener('click', (e) => {
      if (dateInputVisible && !dateInputPanel.contains(e.target) && e.target !== currentDateEl) {
        hideDateInput();
      }
    });
    
    // Date navigation buttons
    backWeekBtn.addEventListener('click', () => navigateByDays(-7));
    back3DaysBtn.addEventListener('click', () => navigateByDays(-3));
    next3DaysBtn.addEventListener('click', () => navigateByDays(3));
    nextWeekBtn.addEventListener('click', () => navigateByDays(7));

    toggleLooseBtn.addEventListener('click', () => {
      looseMode = !looseMode;
      toggleLooseBtn.textContent = 'Loose Parsing: ' + (looseMode ? 'ON' : 'OFF');
      if (rawFiles && Object.keys(rawFiles).length) {
        // Re-run parsing if we already loaded a file
        rerunParsing();
      }
    });

    showUnparsedBtn.addEventListener('click', () => {
      if (!unparsedLines.length) {
        unparsedBox.textContent = 'No unparsed lines 🎉';
      } else {
        const sample = unparsedLines.slice(0, 40).join('\n');
        unparsedBox.textContent = sample;
      }
      unparsedBox.style.display = unparsedBox.style.display === 'none' ? 'block' : 'none';
    });

    function rerunParsing() {
      const chatName = pickChatTxt(rawFiles);
      if (!chatName) return;
      let text = '';
      try {
        text = window.fflate.strFromU8(rawFiles[chatName]);
        if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
      } catch (e) {
        console.error(e);
        setProgress('Failed to decode Chat.txt as UTF-8. The file may be corrupted or use an unsupported encoding.');
        return;
      }
      operationStartTime = Date.now();
      setProgress('Analyzing transcript…', true);
      parseChatText(text);
      
      // Initialize ListView if not already done
      if (!listView) {
        initializeListView();
      }
      
      // Set messages in ListView
      setMessagesInListView(messages);
      
      updateStats();
      applyFilter(); // Use applyFilter to handle all current filter settings
    }


    // Control Panel Minimize/Expand functionality
    const minimizeBtn = document.getElementById('minimizeBtn');
    const controlPanel = document.getElementById('controlPanel');
    const panelHeader = document.getElementById('panelHeader');
    const panelContent = document.getElementById('panelContent');
    const minimizeIcon = document.getElementById('minimizeIcon');
    const minimizeText = document.getElementById('minimizeText');
    
    let isMinimized = false;
    
    minimizeBtn.addEventListener('click', () => {
      isMinimized = !isMinimized;
      const mainEl = document.querySelector('main');
      
      if (isMinimized) {
        controlPanel.classList.add('minimized');
        panelHeader.classList.add('minimized');
        panelContent.classList.add('minimized');
        mainEl.classList.add('panel-minimized');
        minimizeIcon.textContent = '⌃';
        minimizeText.textContent = 'Expand';
      } else {
        controlPanel.classList.remove('minimized');
        panelHeader.classList.remove('minimized');
        panelContent.classList.remove('minimized');
        mainEl.classList.remove('panel-minimized');
        minimizeIcon.textContent = '⌄';
        minimizeText.textContent = 'Minimize';
      }
      
      // Save state to localStorage
      try {
        localStorage.setItem('whz_panel_minimized', isMinimized);
      } catch {}
    });
    
    // Restore minimize state on load
    try {
      const savedState = localStorage.getItem('whz_panel_minimized');
      if (savedState === 'true') {
        minimizeBtn.click();
      }
    } catch {}

    /*** File intake ***/
    // chooseBtn click handler removed - native label behavior handles file picker opening
    fileInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (f) handleZipFile(f);
    });

    ;['dragenter','dragover'].forEach(t => dropzone.addEventListener(t, (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.add('drag'); }));
    ;['dragleave','drop'].forEach(t => dropzone.addEventListener(t, (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('drag'); }));
    dropzone.addEventListener('drop', (e) => {
      const f = e.dataTransfer?.files?.[0];
      if (f) { 
        fileInput.files = e.dataTransfer.files; 
        // Don't call handleZipFile directly - let the change event handle it
      }
    });

    async function handleZipFile(file) {
      resetState();
      const name = file.name || 'unknown.zip';
      fileNameEl.textContent = name;
      try { sessionStorage.setItem('whz_zip_name', name); } catch {}

      if (!/\.zip$/i.test(name)) {
        setProgress('Please choose a .zip file. Only WhatsApp exported ZIP files are supported.');
        return;
      }
      
      operationStartTime = Date.now();
      setProgress(`Reading ZIP (${formatFileSize(file.size)})…`, true);

      let ab;
      try {
        ab = await file.arrayBuffer();
      } catch (e) {
        console.error(e);
        setProgress('Failed to read file. The file may be too large or corrupted.');
        return;
      }

      setProgress('Unzipping… (client-side)', true);
      window.fflate.unzip(new Uint8Array(ab), (err, files) => {
        if (err) {
          console.error(err);
          setProgress('ZIP is corrupted or unsupported. Try exporting the chat again from WhatsApp.');
          return;
        }
        rawFiles = files || {};
        fileIndexByBase = {};
        
        // Build file index quickly
        const fileNames = Object.keys(rawFiles);
        for (const full of fileNames) {
          const base = getBaseName(full);
          if (!(base in fileIndexByBase)) fileIndexByBase[base] = full;
        }
        
        const elapsed = Date.now() - operationStartTime;
        setProgress(`Extracted ${fileNames.length} files in ${formatDuration(elapsed)}`);
        
        setTimeout(() => {
          const chatName = pickChatTxt(rawFiles);
          if (!chatName) {
            setProgress('No chat transcript found. Ensure your WhatsApp export contains the .txt file.');
            return;
          }
          rerunParsing(); // decodes + parses + renders
        }, 500);
      });
    }

    // Clipboard paste
    document.addEventListener('paste', (e) => {
      const files = e.clipboardData?.files;
      if (files && files.length) {
        const f = files[0];
        if (/\.zip$/i.test(f.name)) {
          handleZipFile(f);
        }
      }
    });

  })();
  </script>
</body>
</html>